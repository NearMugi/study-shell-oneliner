# 第2章シェルの基本 2.1 変数と制御構文、コマンドの入出力操作を把握する

## P55 練習 2.1.a 標準入出力・標準エラー出力

```bash
# 標準出力
ls -l 1>a

# 標準入力  ※wc -l は aの行数をカウント
wc -l 0<a

# 標準エラー出力
sed 2>a
```

0<, 1>, 2> の数字はファイル記述子(ファイルディスクリプタ file descriptor)というもので、コマンドの入出力先がどこかを管理するための番号。  
0, 1, 2 はそれぞれ標準入力、標準出力、標準エラー出力を表している。  
コマンドが独自にファイルを開いてデータを読み書きするときには、３以上の番号がファイルへの接続のために割り当てられる。  

### 標準エラー出力のパイプ渡し

```bash
# n>&m n番目を今m番目に繋がっている先に振り向ける。
sed 2>&1 | wc -l
# 標準出力も標準エラー出力もまとめて右のコマンドに渡す。
sed |& wc -l
```

## P58 練習 2.1.b シェルと変数

```bash
# (おまけ)環境変数を探す
env | grep -i shell

echo $SHELL
# <<< は変数をコマンドに入力するためのリダイレクト
cat <<< $SHELL

```

## P59 練習 2.1.c 文字列の連結と置換

```bash
a=私は
b=俳優よ

c=$a$b ; echo $c
# 私は俳優よ

a+=$b ; echo $a
# 私は俳優よ

b=${a:0:1}${a:2:2} ; echo $b 
# 私俳優

c=${a/俳優/パーコー麺} ; echo $c
# 私はパーコー麺よ

```

## P60 練習 2.1.d 変数を使った計算

```bash
a=6
b=2
echo $((a+b)) $((b-a)) $((a*b)) $((a/b)) $((b**(a+1)))
# 8 -4 12 3 128

echo $((a+b)) $((b-a)) $((a*b)) $((a/b)) $((b<<a))
# 8 -4 12 3 128

```

## P61 練習 2.1.e クォートと変数

* awkを使う際、引数に与えるAWKのコードをシングルクォート('')で囲んでいた
* 理由は2つ
  * {print 1+1} のように空白の入った引数をひとまとめに渡すため
  * $1 などのAWKの変数が、シェルの変数として解釈されることを防止するため
* Bashの変数を使いたいときはダブルクォート("")で囲む
* ただしダブルクォートでその変数を囲うかどうかで挙動が代わってしまうこともある。その場合は ${} で囲むことで回避できる

```bash
p=pen
re=""

echo $p "$p" '$p'
# pen pen $p

echo "This is a ${p}cil." That is a "$p"cil. "That was a $pcil."
# This is a pencil. That is a pencil. That was a .

# grep "" README.md と解釈される -> 検索語が空文字になるため全ての行がヒットする
grep "$re" README.md
# # study-shell-oneliner

# [1日1問、半年以内に習得 シェル・ワンライナー160本ノック (Software Design plusシリーズ)](https://www.amazon.co.jp/gp/product/4297122677/ref=ppx_yo_dt_b_asin_title_o01_s00?ie=UTF8&psc=1)を学習する

# grep README.md と解釈される -> 何も動かないバグになる
grep $re README.md

```

## P

```bash

```

