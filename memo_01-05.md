# 第1章Linux環境 1.5 もっとawkとsedに慣れる

## P43 問題5 設定ファイルからの情報抽出

```bash
FILE="../shellgei160/qdata/5/ntp.conf"
cat ${FILE} | awk '$1=="pool"' | awk '{print $2}'
```

## P44 問題6 端末に模様を描く

```bash
# 以下を出力する
#    X
#   X
#  X
# X
#X

seq 5 | awk '{for(i=1;i<$1;i++){printf " "}; print "X"}' | tac
# seq 5 | awk '{for(i=1;i<$1;i++){printf " "}; print "X"}' で seq のサイズ分だけ空白を入れてXを出力する
# tac で出力順を逆にする

seq 5 -1 1| awk '{for(i=1;i<$1;i++){printf " "}; print "X"}'
# seq の値を上から減らしていくパターン
# tac が不要になる

seq 5 | awk '{a++; for(i=5;i>a;i--){printf " "};print "X"}'
# seq の値を 変数a に入れて空白を出力

seq 5 | awk '{for(i=5;i>NR;i--){printf " "};print "X"}'
# 行番号が入るawkの 変数NR を使う
# 1,2,3,4,5 となる

printf "%*s\n" 5 X 4 X 3 X 2 X 1 X
# printf "%5s\n" X は 文字列の長さを5に指定している
# printf "%*s\n" 5 X は 文字列の長さを引数にして渡している
# printf "%5s\n" X YY ZZZ は "%5s\n" を連続適用する
#    X
#   YY
#  ZZZ

seq 5 -1 1 | awk '{printf "%*s\n",$1,"X"}'
# 上記と同義

echo '    X' | sed ':a; p; s/ //; ta; d'
# :a はラベル
# ta は前の命令(s/ //)が成功したらラベルaに戻る
# p はプリントする 
# s/ // は空白を一つ削除
# d は残った文字列を削除

echo '    X' | awk '{print;while(sub(/ /,"",$0))print}'
# sub関数は変換した文字を返す
# ここでは 文字全体に対して空白を一つ削除する
# 成功すると1を返す
# 成功し続ける限りループを繰り返す

```

## P46 問題7 消費税

```bash
FILE_PATH='../shellgei160/qdata/7/kakeibo.txt'

# 消費税率を4列目に追加
cat $FILE_PATH | awk '{print $0, 1.1}'
# 20190901 ゼロカップ大関 10000 1.1
# 20190902 *キャベツ二郎 130 1.1
# 20191105 外食 13000 1.1
# 20191106 ストロングワン 13000 1.1
# 20191106 *ねるねるねるねる 30 1.1
# 20190912 外食 13000 1.1

# 2019/10/1 以前、または * が付いているものは1.08、それ以外は 1.1にする
cat $FILE_PATH | awk '{tax=($1<"20191001" || $2~"^*") ? 1.08 : 1.1; print $0,tax}'
# 20190901 ゼロカップ大関 10000 1.08
# 20190902 *キャベツ二郎 130 1.08
# 20191105 外食 13000 1.1
# 20191106 ストロングワン 13000 1.1
# 20191106 *ねるねるねるねる 30 1.08
# 20190912 外食 13000 1.08

# それぞれ掛け合わせる
cat $FILE_PATH | awk '{tax=($1<"20191001" || $2~"^*") ? 1.08 : 1.1; print $0,tax}' | awk '{print int($3*$4)}'
# 10800
# 140
# 14300
# 14300
# 32
# 14040

# 合計を出す
# numsum は入力された数値の合計値を出す
cat $FILE_PATH | awk '{tax=($1<"20191001" || $2~"^*") ? 1.08 : 1.1; print $0,tax}' | awk '{print int($3*$4)}' | numsum
# 53612

```

## P48 問題8 ログの集計

```bash
FILE_PATH='../shellgei160/qdata/8/access.log'

# そのまま出力してみる
awk -F ":" '{print $0}' $FILE_PATH
# 183.YY.129.XX - - [07/Nov/2017:22:37:38 +0900]
# 192.Y.220.XXX - - [08/Nov/2017:02:17:16 +0900]
# 66.YYY.79.XXX - - [07/Nov/2017:14:42:48 +0900]
# ::1 - - [07/Nov/2017:13:37:54 +0900]
# 133.YY.23.XX - - [07/Nov/2017:09:41:48 +0900]

# : で区切ればよい。ただ先頭から参照すると ::1 で想定しない場所で区切ってしまう
# 末尾から2番目(NF-2)を参照する
# ※ NF は Number of Fields の略

awk -F ":" '{print $(NF-2)}' $FILE_PATH
# 22
# 02
# 14
# 13
# 09

# 条件を入れる
awk -F ":" '{print $(NF-2)}' $FILE_PATH | awk '$1<12{print "AM"} $1>=12{print "PM"}' 
# PM
# AM
# PM
# PM
# AM

# ソート & カウント
awk -F ":" '{print $(NF-2)}' $FILE_PATH | awk '$1<12{print "AM"} $1>=12{print "PM"}' | sort | uniq -c
#      2 AM
#      3 PM
      
```

別解  
時間表記に変換してdateコマンドを利用する

```bash
FILE_PATH='../shellgei160/qdata/8/access.log'

sed -r 's@.*\[|\]|/@@g' $FILE_PATH
# -r は -E と同じ正規表現を使うオプション
# @ は区切り文字 s/置換前/置換後/g -> s@置換前@置換後@g
# | は OR記号
# .*\[ | \] | / なので
# "[以前の文字列" または "]" または "/" が条件に一致する

# 出力
# 07Nov2017:22:37:38 +0900
# 08Nov2017:02:17:16 +0900
# 07Nov2017:14:42:48 +0900
# 07Nov2017:13:37:54 +0900
# 07Nov2017:09:41:48 +0900

sed -r 's@.*\[|\]|/@@g; s/:/ /' $FILE_PATH
# 一番最初の : を 空白に変換

# 出力
# 07Nov2017 22:37:38 +0900
# 08Nov2017 02:17:16 +0900
# 07Nov2017 14:42:48 +0900
# 07Nov2017 13:37:54 +0900
# 07Nov2017 09:41:48 +0900

sed -r 's@.*\[|\]|/@@g; s/:/ /' $FILE_PATH | date -f- +%p
# dateコマンドで 午前 or 午後 に変換

# 出力
# 午後
# 午前
# 午後
# 午後
# 午前
```

### dateコマンドの補足

```bash
# date だけだと現在の日付を返す
date
# 出力
# 2024年  3月 18日 月曜日 22:58:10 JST

# フォーマットを指定
date +%p
# 出力
# 午後

date "+%Y%m%d %H%M%S"
# 出力
# 20240318 230150

# date -f はファイルから時刻を読み込む
# date -f- はパイプからデータを受け入れる

```